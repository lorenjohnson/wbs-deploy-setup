import { createSession, createChannel } from 'better-sse';
import crypto from 'crypto';
import { Eta } from 'eta';
import express from 'express';
import { existsSync, readFileSync, createReadStream } from 'fs';
import { writeFile, readFile } from 'fs/promises';
import https, { request } from 'https';
import { dirname, join } from 'path';
import readline from 'readline';
import { fileURLToPath } from 'url';

const fileName = fileURLToPath( import.meta.url );
const dirName = dirname( fileName );

// Constants
const ENV_FILE_PATH = '/app/deploy/.env';
const ENV_TEMPLATE_FILE_PATH = '/app/deploy/template.env';
const LOG_PATH = '/app/setup.log';
const SSL_CERT_KEY_PATH = '/app/certs/key.pem';
const SSL_CERT_PATH = '/app/certs/cert.pem';
// 10 minutes
const AUTO_FINALIZE_TIMEOUT_MS = 10 * 60 * 1000;

// Express setup
const app = express();
app.use( express.static( join( dirName, 'public' ) ) );
app.use( express.json() );

// Eta setup
const eta = new Eta( {
	views: join( dirName, 'views' ),
	cache: false,
	useWith: true
} );

// Helpers
const generatePassword = (): string => crypto.randomBytes( 12 ).toString( 'base64' );

function buildEnvContent( input: Record<string, string> ): {
	config: Record<string, string | boolean>;
	content: string;
} {
	const config = buildConfig( input );
	const content = [
		'# Autogenerated .env file from installer UI',
		...Object.entries( config ).map( ( [ k, v ] ) => `${ k }=${ v }` )
	].join( '\n' ) + '\n';
	return { config, content };
}

function isConfigSaved(): boolean {
	return existsSync( ENV_FILE_PATH );
}

function isBooted(): boolean {
	if ( !existsSync( LOG_PATH ) ) {
		return false;
	}
	const log = readFileSync( LOG_PATH, 'utf8' );
	return log.includes( 'Setup is Complete!' );
}

// Note: Returns a default config when called without input (some transcribe from template.env)
function buildConfig( input: Record<string, string> = {} ): Record<string, string | boolean> {
	const templateLines = readFileSync( ENV_TEMPLATE_FILE_PATH, 'utf8' ).split( '\n' );
	const templateEnv: Record<string, string> = {};
	for ( const line of templateLines ) {
		const match = line.match( /^([^#=\s]+)=(.*)$/ );
		if ( match ) {
			templateEnv[ match[ 1 ] ] = match[ 2 ];
		}
	}

	return {
		WIKIBASE_PUBLIC_HOST: input.WIKIBASE_PUBLIC_HOST,
		WDQS_PUBLIC_HOST: input.WDQS_PUBLIC_HOST || input.WIKIBASE_PUBLIC_HOST ? `query.${ input.WIKIBASE_PUBLIC_HOST }` : '',
		MW_ADMIN_NAME: input.MW_ADMIN_NAME || templateEnv.MW_ADMIN_NAME,
		MW_ADMIN_EMAIL: input.MW_ADMIN_EMAIL,
		MW_ADMIN_PASS: input.MW_ADMIN_PASS || generatePassword(),
		DB_NAME: input.DB_NAME || templateEnv.DB_NAME,
		DB_USER: input.DB_USER || templateEnv.DB_USER,
		DB_PASS: input.DB_PASS || generatePassword(),
		METADATA_CALLBACK: true
	};
}

function getCurrentConfig(): Record<string, string> {
	if ( !isConfigSaved() ) {
		return {};
	}
	const lines = readFileSync( ENV_FILE_PATH, 'utf8' ).split( '\n' );
	const env: Record<string, string> = {};
	for ( const line of lines ) {
		const match = line.match( /^([^#=\s]+)=(.*)$/ );
		if ( match ) {
			env[ match[ 1 ] ] = match[ 2 ];
		}
	}
	return env;
}

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function getStatusPayload() {
	const configSaved = isConfigSaved();
	const booted = isBooted();
	const config = getCurrentConfig();
	return { isConfigSaved: configSaved, isBooted: booted, config };
}

// ---------- Routes ----------
app.get( '/', async ( req, res ) => {
	try {
		const config = isConfigSaved() ? getCurrentConfig() : buildConfig();
		const html = eta.render( 'index.eta', {
			...config,
			isConfigSaved: isConfigSaved(),
			isBooted: isBooted(),
			SERVER_IP: process.env.SERVER_IP
		} );
		if ( !html ) {
			throw new Error( 'Eta render returned null' );
		}
		res.type( 'html' ).send( html );
	} catch ( err ) {
		console.error( 'Failed to render template:', err );
		res.status( 500 ).send( 'Template render error' );
	}
} );

const logChannel = createChannel();

// Single log endpoint with backfill of the entire file on fresh page load
app.get( '/log/stream', async ( req, res ) => {
	const session = await createSession( req, res ); // sets SSE headers, heartbeats, ids
	logChannel.register( session );

	// Backfill ENTIRE log only on a fresh page load (skip on auto-reconnects)
	const isReconnect = typeof req.headers[ 'last-event-id' ] === 'string' && req.headers[ 'last-event-id' ] !== '';
	if ( !isReconnect && existsSync( LOG_PATH ) ) {
		const rs = createReadStream( LOG_PATH, { encoding: 'utf8' } );
		const rl = readline.createInterface( { input: rs, crlfDelay: Infinity } );
		await session.batch( async ( buffer ) => {
			for await ( const line of rl ) {
				if ( line ) {
					buffer.push( line ); // one SSE message per log line
				}
			}
		} );
	}
} );

app.post( '/write-env', async ( req, res ): Promise<void> => {
	try {
		const { config, content } = buildEnvContent( req.body );
		await writeFile( ENV_FILE_PATH, content );
		console.log( '.env file written successfully' );
		res.status( 200 ).json( { status: 'ok', generated: config } );
	} catch ( err ) {
		console.error( 'Failed to write .env:', err );
		res.status( 500 ).send( 'Failed to write .env' );
	}
} );

// Finalize endpoint unchanged
app.post( '/finalize-setup', async ( req, res ) => {
	try {
		if ( existsSync( ENV_FILE_PATH ) ) {
			const lines = ( await readFile( ENV_FILE_PATH, 'utf8' ) ).split( '\n' );
			// blank password values
			const sanitized = lines.map( ( line ) =>
				line.replace( /^(.*_PASS(?:WORD)?=).+$/, '$1' )
			);
			await writeFile( ENV_FILE_PATH, sanitized.join( '\n' ) );
			console.log( 'üßº Passwords sanitized' );
		}

		if ( existsSync( LOG_PATH ) ) {
			await writeFile( LOG_PATH, '' );
			console.log( 'üßπ Log cleared' );
		}

		res.status( 200 ).json( { status: 'finalized' } );
		console.log( 'üí§ Setup finalized. Exiting...' );
		// eslint-disable-next-line n/no-process-exit
		setTimeout( () => process.exit( 0 ), 300 ); // allow response to finish
	} catch ( err ) {
		console.error( '‚ùå Finalize error:', err );
		res.status( 500 ).send( 'Failed to finalize setup' );
	}
} );

// --- Broadcasters ---
// Log tailer: every 1s read lines and broadcast only the new ones
{
	let lastCount = 0;
	setInterval( () => {
		if ( !existsSync( LOG_PATH ) ) {
			return;
		}
		try {
			const lines = readFileSync( LOG_PATH, 'utf8' ).split( '\n' );
			if ( lines.length < lastCount ) {
				lastCount = 0;
			} // file truncated/cleared
			for ( let i = lastCount; i < lines.length; i++ ) {
				const line = lines[ i ];
				if ( line ) {
					logChannel.broadcast( line );
				}
			}
			lastCount = lines.length;
		} catch ( e ) {
			// ignore transient read errors
		}
	}, 1000 );
}

if ( !existsSync( SSL_CERT_PATH ) || !existsSync( SSL_CERT_KEY_PATH ) ) {
	throw new Error( 'Not able to access SSL certificate or key in /app/certs' );
}

const credentials = {
	cert: readFileSync( SSL_CERT_PATH ),
	key: readFileSync( SSL_CERT_KEY_PATH )
};

https.createServer( credentials, app ).listen( 443, () => {
	console.log( '‚úÖ HTTPS server running at https://localhost:443' );
} );

// Kick off finalize if booted and inactive
setTimeout( () => {
	if ( isBooted() ) {
		console.log( '‚è±Ô∏è Auto-finalizing setup after timeout...' );

		const req = request(
			{
				method: 'POST',
				host: 'localhost',
				port: 443,
				path: '/finalize-setup',
				rejectUnauthorized: false, // allow self-signed certs
				headers: {
					'Content-Type': 'application/json'
				}
			},
			( res ) => {
				if ( res.statusCode && res.statusCode >= 200 && res.statusCode < 300 ) {
					console.log( '‚úÖ Auto-finalize complete' );
				} else {
					console.error( `‚ùå Auto-finalize failed: ${ res.statusCode }` );
				}
			}
		);

		req.on( 'error', ( err ) => {
			console.error( '‚ùå Auto-finalize request error:', err );
		} );

		req.end(); // no body needed
	} else {
		console.log( '‚è±Ô∏è Auto-finalize skipped: not yet booted' );
	}
}, AUTO_FINALIZE_TIMEOUT_MS );
